name: Deploy to Kubernetes

on:
  push:
    branches:
      - main
  pull_request:
    branches:
      - "**"

jobs:
  test:
    runs-on: ubuntu-latest

    services:
      docker:
        image: docker:20.10.7
        options: --privileged

    steps:
      # Step 1: Checkout the repository
      - name: Checkout repository
        uses: actions/checkout@v2

      # Step 2: Check for active ports
      - name: Check for active ports
        run: |
          echo "Listing active ports..."
          sudo netstat -tuln

      # Step 3: Set up Docker Compose
      - name: Set up Docker Compose
        uses: docker/setup-buildx-action@v1

      # Step 4: Start Docker Compose
      - name: Start Docker Compose services
        run: docker compose up -d

      # Step 5: Wait for services to be healthy
      - name: Wait for services to be healthy
        run: |
          echo "Waiting for services to be healthy..."
          sleep 60

      # Step 6: Check if all services are running
      - name: Check Docker Compose service status
        run: |
          echo "Checking services' status..."
          docker compose ps

          # Count number of running containers
          RUNNING_CONTAINERS=$(docker compose ps | grep 'Up' | wc -l)

          # Check if all containers are running (remove header line)
          TOTAL_CONTAINERS=$(docker compose ps | wc -l | xargs -I {} expr {} - 1)

          if [ "$RUNNING_CONTAINERS" -ne "$TOTAL_CONTAINERS" ]; then
            echo "Not all containers are up and running. Failing the test."
            exit 1
          else
            echo "All containers are up and running."
          fi

      # Step 7: Tear down services after the test
      - name: Tear down Docker Compose
        if: always()
        run: docker compose down
  deploy:
    runs-on: ubuntu-latest
    needs: test
    strategy:
      matrix:
        kubeconfig_secret_name: [HIRO_KUBE_CONFIG_AWS, HIRO_KUBE_CONFIG_BASTON]
    steps:
      - name: Checkout code
        uses: actions/checkout@v2

      - name: Set up Kubeconfig
        run: |
          mkdir -p ~/.kube
          echo "${{ secrets[matrix.kubeconfig_secret_name] }}" > ~/.kube/${{ matrix.kubeconfig_secret_name }}
          chmod 600 ~/.kube/${{ matrix.kubeconfig_secret_name }}

      - name: Set Helm dry-run flag
        id: helm-dry-run
        run: |
          if [[ "${{ github.event_name }}" == "push" ]]; then
            echo "flag=" >> $GITHUB_OUTPUT
          else
            echo "flag=--dry-run" >> $GITHUB_OUTPUT
          fi

      - name: Set Helm values for Service type and Ingress
        id: helm-app-access
        run: |
          if [[ "${{ matrix.kubeconfig_secret_name }}" == "HIRO_KUBE_CONFIG_AWS" ]]; then
            echo "grafana_service_type=--set nginxReverseProxy.service.type=NodePort" >> $GITHUB_OUTPUT
            echo "grafana_service_nodePort=--set nginxReverseProxy.service.nodePort=${{ vars.GRAFANA_NODE_PORT }}" >> $GITHUB_OUTPUT
            echo "orchestrator_ui_ingress_enabled=--set app.ingress.enabled=false" >> $GITHUB_OUTPUT
            echo "orchestrator_ui_ingress_host=" >> $GITHUB_OUTPUT
            echo "k8s_proxy_service_type=--set app.k8sProxy.service.type=NodePort" >> $GITHUB_OUTPUT
            echo "k8s_proxy_service_nodePort=--set app.k8sProxy.service.nodePort=${{ vars.K8S_PROXY_NODE_PORT }}" >> $GITHUB_OUTPUT
            echo "k8s_proxy_ingress_enabled=--set app.k8sProxy.ingress.enabled=false" >> $GITHUB_OUTPUT
            echo "k8s_proxy_ingress_host=" >> $GITHUB_OUTPUT
          else
            echo "orchestrator_ui_service_type=--set app.service.type=ClusterIP" >> $GITHUB_OUTPUT
            echo "orchestrator_ui_service_nodePort=" >> $GITHUB_OUTPUT
            echo "orchestrator_ui_ingress_enabled=--set app.ingress.enabled=true" >> $GITHUB_OUTPUT
            echo "orchestrator_ui_ingress_host=--set app.ingress.host=${{ vars.ORCHESTRATOR_LIBRARY_UI_INGRESS_HOST }}" >> $GITHUB_OUTPUT
            echo "k8s_proxy_service_type=--set app.k8sProxy.service.type=ClusterIP" >> $GITHUB_OUTPUT
            echo "k8s_proxy_service_nodePort=" >> $GITHUB_OUTPUT
            echo "k8s_proxy_ingress_enabled=--set app.k8sProxy.ingress.enabled=true" >> $GITHUB_OUTPUT
            echo "k8s_proxy_ingress_host=--set app.k8sProxy.ingress.host=${{ vars.K8S_PROXY_INGRESS_HOST }}" >> $GITHUB_OUTPUT
          fi
          
      - name: Deploy to Kubernetes
        env:
          MONITORING_NAMESPACE: ${{ vars.MONITORING_NAMESPACE }}
          RELEASE_NAME: ${{ vars.MONITORING_RELEASE_NAME }} # used in post-renderer script
        run: |
          if [ -z "$MONITORING_NAMESPACE" ]; then
            echo "MONITORING_NAMESPACE variable is not set"
            exit 1
          fi
          if [ -z "$RELEASE_NAME" ]; then
            echo "RELEASE_NAME variable is not set"
            exit 1
          fi
          helm upgrade --install $RELEASE_NAME ./charts/app \
            --post-renderer ./charts/app/add-common-labels.sh \
            --kubeconfig ~/.kube/${{ matrix.kubeconfig_secret_name }} \
            -n "$MONITORING_NAMESPACE" --create-namespace \
            --wait --debug \
            ${{ steps.helm-dry-run.outputs.flag }}
            

      - name: Clean up
        run: rm -rf ~/.kube/${{ matrix.kubeconfig_secret_name }}